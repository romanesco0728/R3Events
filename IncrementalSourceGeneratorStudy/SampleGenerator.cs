using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace IncrementalSourceGeneratorStudy;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitDefaultAttribute);

        // Find class declarations that have attributes (candidate for the R3EventAttribute)
        var classWithAttributes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
            transform: static (ctx, _) =>
            {
                var classDecl = (ClassDeclarationSyntax)ctx.Node;
                var classSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
                if (classSymbol == null)
                    return default((INamedTypeSymbol? ClassSymbol, INamedTypeSymbol? TargetType));

                // Look for Events.R3.R3EventAttribute on the class
                foreach (var attrib in classSymbol.GetAttributes())
                {
                    var attrClass = attrib.AttributeClass;
                    if (attrClass == null)
                        continue;

                    // match by metadata name to be robust even when attribute is generated in post-init
                    if (attrClass.ToDisplayString() == "Events.R3.R3EventAttribute")
                    {
                        // Expect one constructor argument: typeof(TargetType)
                        if (attrib.ConstructorArguments.Length == 1)
                        {
                            var arg = attrib.ConstructorArguments[0];
                            if (arg.Value is INamedTypeSymbol targetTypeSymbol)
                            {
                                return (ClassSymbol: classSymbol, TargetType: targetTypeSymbol);
                            }
                        }
                    }
                }

                return default((INamedTypeSymbol? ClassSymbol, INamedTypeSymbol? TargetType));
            })
            .Where(static m => m.ClassSymbol is not null && m.TargetType is not null);

        // Collect and generate source
        var collected = classWithAttributes.Collect();
        var compilationAndItems = context.CompilationProvider.Combine(collected);
        context.RegisterSourceOutput(compilationAndItems, static (spc, pair) =>
        {
            var compilation = pair.Left;
            var items = pair.Right; // ImmutableArray<(INamedTypeSymbol? ClassSymbol, INamedTypeSymbol? TargetType)>
            foreach (var item in items)
            {
                var classSymbol = item.ClassSymbol;
                var targetType = item.TargetType;
                if (classSymbol == null || targetType == null)
                    continue;

                var generatedNamespace = "Events.R3.Generated";
                var sb = new StringBuilder();

                // Determine if System.ComponentModel is needed (e.g. CancelEventArgs)
                bool needsComponentModel = false;

                // File header
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("namespace " + generatedNamespace);
                sb.AppendLine("{");
                sb.AppendLine("    using global::System;");
                sb.AppendLine("    using global::System.Threading;");

                // We'll collect using for ComponentModel if necessary later; but append placeholder

                sb.AppendLine();

                // partial class declaration
                var classAccessibility = classSymbol.DeclaredAccessibility == Accessibility.Public ? "public" : "internal";
                sb.AppendLine($"    {classAccessibility} static partial class {classSymbol.Name}");
                sb.AppendLine("    {");

                // Iterate public events on targetType
                foreach (var member in targetType.GetMembers())
                {
                    if (member is IEventSymbol ev && ev.DeclaredAccessibility == Accessibility.Public)
                    {
                        // Determine payload type for Observable<T>
                        var eventType = ev.Type as INamedTypeSymbol;
                        ITypeSymbol? payloadType = null;

                        // special-case: System.EventHandler -> global::R3.Unit
                        if (eventType != null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler")
                        {
                            // Use R3.Unit
                            // We'll represent as "global::R3.Unit"
                        }
                        else if (eventType != null && eventType.IsGenericType && eventType.ConstructedFrom?.ToDisplayString() == "System.EventHandler<TEventArgs>")
                        {
                            // EventHandler<T>
                            payloadType = eventType.TypeArguments[0];
                        }
                        else
                        {
                            // Try to get Invoke method on delegate to find last parameter type
                            var invoke = (eventType)?.DelegateInvokeMethod;
                            if (invoke != null)
                            {
                                var ps = invoke.Parameters;
                                if (ps.Length >= 1)
                                {
                                    payloadType = ps[ps.Length - 1].Type;
                                }
                            }
                        }

                        // If still null and eventType is null, fallback to System.Object
                        if (payloadType == null && !(eventType != null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler"))
                        {
                            payloadType = compilation.GetTypeByMetadataName("System.Object");
                        }

                        // Decide observable element type string
                        string observableElementType;
                        bool useAsUnit = false;
                        if (eventType != null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler")
                        {
                            observableElementType = "global::R3.Unit";
                            useAsUnit = true;
                        }
                        else if (payloadType != null)
                        {
                            var payloadDisplay = payloadType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            observableElementType = payloadDisplay.Replace("global::", "global::");
                            if (payloadDisplay.StartsWith("global::System.ComponentModel."))
                            {
                                needsComponentModel = true;
                            }
                        }
                        else
                        {
                            observableElementType = "global::System.Object";
                        }

                        // Generate method
                        var eventName = ev.Name;
                        sb.AppendLine("        /// <summary>");
                        sb.AppendLine($"        /// Returns an Observable for <c>{eventName}</c>.");
                        sb.AppendLine("        /// </summary>");

                        var targetTypeDisplay = targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                        sb.AppendLine($"        public static global::R3.Observable<{observableElementType}> {eventName}AsObservable(this {targetTypeDisplay} instance, global::System.Threading.CancellationToken cancellationToken = default)");
                        sb.AppendLine("        {");

                        // Build FromEvent / FromEventHandler usage
                        if (useAsUnit)
                        {
                            sb.AppendLine("            var rawObservable = global::R3.Observable.FromEventHandler(");
                            sb.AppendLine("                h => instance." + eventName + " += h,");
                            sb.AppendLine("                h => instance." + eventName + " -= h,");
                            sb.AppendLine("                cancellationToken");
                            sb.AppendLine("                );");
                            sb.AppendLine("            return rawObservable.AsUnitObservable();");
                        }
                        else
                        {
                            // Use FromEvent<Delegate, (object?, Payload)> and Select to extract Args or second tuple element
                            var delegateTypeDisplay = eventType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::System.Delegate";
                            var payloadTypeDisplay = observableElementType;

                            // Create tuple type string like (object?, Payload Args)
                            var tupleType = $"(object?, {payloadTypeDisplay} Args)";

                            sb.AppendLine($"            var rawObservable = global::R3.Observable.FromEvent<{delegateTypeDisplay}, {tupleType}>(");
                            sb.AppendLine($"                static h => new {delegateTypeDisplay}((s, e) => h((s, e))),");
                            sb.AppendLine($"                h => instance.{eventName} += h,");
                            sb.AppendLine($"                h => instance.{eventName} -= h,");
                            sb.AppendLine("                cancellationToken");
                            sb.AppendLine("                );");
                            sb.AppendLine("            return global::R3.ObservableExtensions.Select(rawObservable, ep => ep.Args);");
                        }

                        sb.AppendLine("        }");
                        sb.AppendLine();
                    }
                }

                sb.AppendLine("    }");

                // Close namespace
                sb.AppendLine("}");

                // If System.ComponentModel is needed, we can add an additional file-level using by simple text replace. For simplicity, include the using if needed by inserting it after System.Threading using.
                var sourceText = sb.ToString();
                if (needsComponentModel)
                {
                    sourceText = sourceText.Replace("    using global::System.Threading;\n\n", "    using global::System.Threading;\n    using global::System.ComponentModel;\n\n");
                }

                var fileName = $"Events.R3.Generated.{targetType.Name}.g.cs";
                spc.AddSource(fileName, SourceText.From(sourceText, Encoding.UTF8));
            }
        });
    }

    private static void EmitDefaultAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        var code = """
            namespace Events.R3
            {
                [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct | global::System.AttributeTargets.Interface, Inherited = false, AllowMultiple = false)]
                internal sealed class R3EventAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="global::Events.R3.R3EventAttribute"/> class with the specified target type.
                    /// </summary>
                    /// <param name="type">The target <see cref="global::System.Type"/> the attribute refers to.</param>
                    public R3EventAttribute(global::System.Type type)
                    {
                        this.Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
                    }
                    /// <summary>
                    /// Gets the target <see cref="global::System.Type"/> represented by this attribute.
                    /// </summary>
                    public global::System.Type Type { get; }
                }
            }
            """;
        context.AddSource("Events.R3.R3EventAttribute.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}
