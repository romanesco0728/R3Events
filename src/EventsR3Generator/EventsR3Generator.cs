using System.Text;
using EventsR3Generator.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EventsR3Generator;

/// <summary>
/// Implements a source generator that produces Observable extension methods for classes decorated with the
/// R3EventAttribute, enabling reactive event handling in C# projects.
/// </summary>
[Generator(LanguageNames.CSharp)]
public partial class EventsR3Generator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get the compilation provider to access language version
        var compilationProvider = context.CompilationProvider;
        
        // Emit the R3EventAttribute definition in post-initialization based on language version
        context.RegisterPostInitializationOutput(ctx =>
        {
            EmitDefaultAttribute(ctx);
        });
        
        // Emit the generic R3EventAttribute<T> if language version supports it (C# 11+)
        var languageVersionProvider = compilationProvider.Select(static (compilation, _) =>
        {
            // Get the maximum language version across all syntax trees to ensure
            // the generic attribute is available when any file uses C# 11+
            var maxLanguageVersion = LanguageVersion.CSharp1;
            
            foreach (var tree in compilation.SyntaxTrees)
            {
                if (tree.Options is CSharpParseOptions parseOptions)
                {
                    if (parseOptions.LanguageVersion > maxLanguageVersion)
                    {
                        maxLanguageVersion = parseOptions.LanguageVersion;
                    }
                }
            }
            
            return maxLanguageVersion;
        });
        
        context.RegisterSourceOutput(languageVersionProvider, static (spc, languageVersion) =>
        {
            if (languageVersion >= LanguageVersion.CSharp11)
            {
                EmitGenericAttribute(spc);
            }
        });

        // Use ForAttributeWithMetadataName to efficiently find classes decorated with R3EventAttribute (non-generic)
        var source = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Events.R3.R3EventAttribute",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
                },
                transform: static (ctx, cancellationToken) => Parse(ctx, cancellationToken)
                );

        // Use ForAttributeWithMetadataName to efficiently find classes decorated with R3EventAttribute<T> (generic)
        var genericSource = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Events.R3.R3EventAttribute`1",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
                },
                transform: static (ctx, cancellationToken) => ParseGeneric(ctx, cancellationToken)
                );

        // Generate source output for each attributed class (non-generic)
        context.RegisterSourceOutput(source, static (spc, item) => EmitSourceOutput(spc, item));
        
        // Generate source output for each attributed class (generic)
        context.RegisterSourceOutput(genericSource, static (spc, item) => EmitSourceOutput(spc, item));
    }

    /// <summary>
    /// Generates and adds the default R3EventAttribute source code to the compilation during post-initialization.
    /// </summary>
    /// <remarks>
    /// This method is intended for use within source generators to ensure the R3EventAttribute is available in the compilation.
    /// The generated attribute is internal and sealed, and is applied to classes  only.</remarks>
    /// <param name="context">The context used to add generated source code during incremental generator post-initialization.</param>
    private static void EmitDefaultAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        // lang=C#-test
        var code = """
// <auto-generated />
namespace Events.R3
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class R3EventAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::Events.R3.R3EventAttribute"/> class with the specified target type.
        /// </summary>
        /// <param name="type">The target <see cref="global::System.Type"/> the attribute refers to.</param>
        public R3EventAttribute(global::System.Type type)
        {
            this.Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the target <see cref="global::System.Type"/> represented by this attribute.
        /// </summary>
        public global::System.Type Type { get; }
    }
}
""";
        context.AddSource("Events.R3.R3EventAttribute.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    /// <summary>
    /// Generates and adds the generic R3EventAttribute{T} source code to the compilation.
    /// This is only emitted when the language version is C# 11 or greater.
    /// </summary>
    /// <remarks>
    /// Generic attributes are supported starting from C# 11.0.
    /// This attribute allows users to specify the target type as a type parameter instead of using typeof().
    /// </remarks>
    /// <param name="context">The context used to add generated source code during source output.</param>
    private static void EmitGenericAttribute(SourceProductionContext context)
    {
        // lang=C#-test
        var code = """
// <auto-generated />
namespace Events.R3
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class R3EventAttribute<T> : global::System.Attribute
    {
    }
}
""";
        context.AddSource("Events.R3.R3EventAttribute_T.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    /// <summary>
    /// Parses the provided generator attribute context to extract property and method information for code generation.
    /// </summary>
    /// <remarks>
    /// This method throws an <see cref="OperationCanceledException"/> if the cancellation token is signaled.
    /// The returned <see cref="ParsedProperty"/> includes fully qualified names and method details for use in code generation scenarios.
    /// </remarks>
    /// <param name="ctx">The generator attribute context containing the target symbol, node, and associated attributes to be parsed.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the parsing operation.</param>
    /// <returns>
    /// A <see cref="ParsedProperty"/> instance containing extracted class metadata and generated method information based on the target type.
    /// </returns>
    private static ParsedProperty Parse(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var classDeclaration = (ClassDeclarationSyntax)ctx.TargetNode;
        var attrib = ctx.Attributes[0];
        var arg = attrib.ConstructorArguments[0];
        var targetTypeSymbol = (INamedTypeSymbol)arg.Value!;

        // Extract method information from the target type
        var generatedMethods = ExtractGeneratedMethods(targetTypeSymbol);
        var targetTypeFullName = targetTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Get class namespace and name
        var containingNamespace = classSymbol.ContainingNamespace;
        var classNamespace = containingNamespace.IsGlobalNamespace ? string.Empty : containingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        return new()
        {
            ClassNamespace = classNamespace,
            ClassName = className,
            ClassDisplayName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            GeneratedMethods = generatedMethods,
            TargetTypeFullName = targetTypeFullName,
            ClassSymbol = new(classSymbol),
            ClassDeclaration = new(classDeclaration),
        };
    }

    /// <summary>
    /// Parses the provided generator attribute context for the generic R3EventAttribute{T} to extract property and method information for code generation.
    /// </summary>
    /// <remarks>
    /// This method handles the generic attribute variant where the target type is specified as a type parameter.
    /// This method throws an <see cref="OperationCanceledException"/> if the cancellation token is signaled.
    /// The returned <see cref="ParsedProperty"/> includes fully qualified names and method details for use in code generation scenarios.
    /// </remarks>
    /// <param name="ctx">The generator attribute context containing the target symbol, node, and associated attributes to be parsed.</param>
    /// <param name="cancellationToken">A cancellation token that can be used to cancel the parsing operation.</param>
    /// <returns>
    /// A <see cref="ParsedProperty"/> instance containing extracted class metadata and generated method information based on the target type.
    /// </returns>
    private static ParsedProperty ParseGeneric(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var classDeclaration = (ClassDeclarationSyntax)ctx.TargetNode;
        var attrib = ctx.Attributes[0];
        
        // For generic attribute, the type is specified as a type argument
        var targetTypeSymbol = (INamedTypeSymbol)attrib.AttributeClass!.TypeArguments[0];

        // Extract method information from the target type
        var generatedMethods = ExtractGeneratedMethods(targetTypeSymbol);
        var targetTypeFullName = targetTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Get class namespace and name
        var containingNamespace = classSymbol.ContainingNamespace;
        var classNamespace = containingNamespace.IsGlobalNamespace ? string.Empty : containingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        return new()
        {
            ClassNamespace = classNamespace,
            ClassName = className,
            ClassDisplayName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            GeneratedMethods = generatedMethods,
            TargetTypeFullName = targetTypeFullName,
            ClassSymbol = new(classSymbol),
            ClassDeclaration = new(classDeclaration),
        };
    }

    /// <summary>
    /// Extracts information about all public, non-static events declared in the specified type.
    /// </summary>
    /// <param name="targetType">
    /// The type symbol representing the target type from which to extract event method information.
    /// </param>
    /// <returns>
    /// An array containing information about each public, non-static event declared in the target type.
    /// The array is ordered by event name and will be empty if no such events are found.
    /// </returns>
    private static EquatableArray<GeneratedMethodInfo> ExtractGeneratedMethods(INamedTypeSymbol targetType)
    {
        var methodInfos = targetType.GetMembers()
            .OfType<IEventSymbol>()
            .Where(static ev => ev is { DeclaredAccessibility: Accessibility.Public, IsStatic: false })
            .Select(static x => GenerateMethodInfo(x))
            .OrderBy(static x => x.EventName)
            .ToArray();
        return new(methodInfos);
    }

    private static GeneratedMethodInfo GenerateMethodInfo(IEventSymbol ev)
    {
        var eventType = ev.Type as INamedTypeSymbol;
        ITypeSymbol? payloadType = null;

        var isNonGenericSystemEventHandler = eventType is { IsGenericType: false } &&
            eventType.ContainingNamespace?.Name is "System" &&
            eventType.MetadataName is "EventHandler";
        if (isNonGenericSystemEventHandler)
        {
            // unit
        }
        else
        {
            var invoke = eventType?.DelegateInvokeMethod;
            if (invoke != null)
            {
                var ps = invoke.Parameters;
                if (ps.Length >= 1) payloadType = ps[^1].Type;
            }
        }

        if (payloadType is null && !isNonGenericSystemEventHandler)
        {
            // Default to System.Object since compilation reference is not available
            payloadType = null;
        }

        string observableElementType;
        bool useAsUnit = false;
        if (isNonGenericSystemEventHandler)
        {
            //eventType.Name
            observableElementType = "global::R3.Unit";
            useAsUnit = true;
        }
        else if (payloadType is not null)
        {
            observableElementType = payloadType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }
        else
        {
            observableElementType = "global::System.Object";
        }

        var delegateTypeDisplay = eventType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::System.Delegate";

        return new()
        {
            EventName = ev.Name,
            ObservableElementType = observableElementType,
            UseAsUnit = useAsUnit,
            DelegateType = delegateTypeDisplay,
        };
    }

    private static void EmitSourceOutput(SourceProductionContext spc, ParsedProperty item)
    {
        if (Diagnose(item) is { } diag)
        {
            spc.ReportDiagnostic(diag);
            return;
        }

        var hintName = $"{item.HintBaseName}.g.cs";
        spc.AddSource(hintName, SourceText.From(GenerateSource(item), Encoding.UTF8));
    }

    /// <summary>
    /// Analyzes the specified property and returns a diagnostic result.
    /// </summary>
    /// <param name="item">The property to analyze for partial declaration.</param>
    /// <returns>A diagnostic indicating that the property must be partial if it is not declared as such; otherwise, <see langword="null"/>.</returns>
    private static Diagnostic? Diagnose(ParsedProperty item)
    {
        if (item.IsNested)
        {
            return Diagnostic.Create(
                DiagnosticDescriptors.MustNotBeNested,
                item.PartialLocation,
                item.ClassDisplayName
                );
        }

        if (!item.IsStatic)
        {
            return Diagnostic.Create(
                DiagnosticDescriptors.MustBeStatic,
                item.PartialLocation,
                item.ClassDisplayName
                );
        }

        if (item.IsGeneric)
        {
            return Diagnostic.Create(
                DiagnosticDescriptors.MustNotBeGeneric,
                item.PartialLocation,
                item.ClassDisplayName
                );
        }

        if (!item.IsPartial)
        {
            return Diagnostic.Create(
                DiagnosticDescriptors.MustBePartial,
                item.PartialLocation,
                item.ClassDisplayName
                );
        }
        return null;
    }

    /// <summary>
    /// Generates C# source code for extension methods that expose events of a parsed property as observables.
    /// </summary>
    /// <remarks>
    /// The generated source code includes extension methods for each event defined in the parsed property.
    /// These methods allow consumers to subscribe to events using the R3 observable pattern.
    /// The output is intended for use in code generation scenarios and is marked as auto-generated.
    /// </remarks>
    /// <param name="item">The parsed property containing event information and target type details used to generate observable extension  methods.
    /// </param>
    /// <returns>
    /// A string containing the generated C# source code for observable extension methods, including namespace and class declarations as appropriate.
    /// </returns>
    private static string GenerateSource(ParsedProperty item)
    {
        var methodsBuilder = new StringBuilder();

        foreach (var methodInfo in item.GeneratedMethods)
        {
            if (methodInfo.UseAsUnit)
            {
                var method = $$"""
        /// <summary>
        /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
        /// </summary>
        public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var rawObservable = global::R3.Observable.FromEventHandler(
                h => instance.{{methodInfo.EventName}} += h,
                h => instance.{{methodInfo.EventName}} -= h,
                cancellationToken
                );
            return global::R3.ObservableExtensions.AsUnitObservable(rawObservable);
        }
""";
                methodsBuilder.AppendLine(method);
            }
            else
            {
                var method = $$"""
        /// <summary>
        /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
        /// </summary>
        public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var rawObservable = global::R3.Observable.FromEvent<{{methodInfo.DelegateType}}, (global::System.Object?, {{methodInfo.ObservableElementType}} Args)>(
                h => new {{methodInfo.DelegateType}}((s, e) => h((s, e))),
                h => instance.{{methodInfo.EventName}} += h,
                h => instance.{{methodInfo.EventName}} -= h,
                cancellationToken
                );
            return global::R3.ObservableExtensions.Select(rawObservable, ep => ep.Args);
        }
""";
                methodsBuilder.AppendLine(method);
            }
        }

        // Namespace of the attribute-bearing class. Empty for global namespace.
        var classNamespace = item.ClassNamespace;
        var className = item.ClassName;

        if (classNamespace.Length > 0)
        {
            return $$"""
// <auto-generated />
#nullable enable
namespace {{classNamespace}}
{
    partial class {{className}}
    {
{{methodsBuilder}}
    }
}
""";
        }
        else
        {
            return $$"""
// <auto-generated />
#nullable disable
partial class {{className}}
{
{{methodsBuilder}}
}
""";
        }
    }


    /// <summary>
    /// Represents metadata describing a generated method for an observable event, including event name, element type,
    /// and delegate information.
    /// </summary>
    private sealed record GeneratedMethodInfo
    {
        /// <summary>
        /// Gets the name of the event associated with this instance.
        /// </summary>
        public required string EventName { get; init; }
        /// <summary>
        /// Gets the name of the element type that is being observed.
        /// </summary>
        public required string ObservableElementType { get; init; }
        /// <summary>
        /// Gets a value indicating whether to use R3.Unit as the element type for the observable.
        /// </summary>
        public required bool UseAsUnit { get; init; }
        /// <summary>
        /// Gets the fully qualified name of the delegate type used for the event handler.
        /// </summary>
        public required string DelegateType { get; init; }
    }

    /// <summary>
    /// Represents metadata for a class and its associated generated Observable extension methods as parsed from an
    /// R3EventAttribute.
    /// </summary>
    private sealed record ParsedProperty
    {
        /// <summary>
        /// Gets the fully qualified namespace of the attributed class, or an empty string if the class is in the global namespace.
        /// </summary>
        public required string ClassNamespace { get; init; }
        /// <summary>
        /// Gets the name of the attributed class.
        /// </summary>
        public required string ClassName { get; init; }
        /// <summary>
        /// Gets a collection of metadata describing the generated Observable extension methods for the attributed class.
        /// </summary>
        public required EquatableArray<GeneratedMethodInfo> GeneratedMethods { get; init; }
        /// <summary>
        /// Gets the fully qualified display name of the attributed class.
        /// </summary>
        public required string ClassDisplayName { get; init; }
        /// <summary>
        /// Gets the fully qualified type name of the target type referenced in the R3EventAttribute.
        /// </summary>
        public required string TargetTypeFullName { get; init; }
        /// <summary>
        /// Gets the symbol of the attributed class.
        /// </summary>
        public required IgnoreEquality<INamedTypeSymbol> ClassSymbol { get; init; }
        /// <summary>
        /// Gets the syntax node representing the class declaration of the attributed class.
        /// </summary>
        public required IgnoreEquality<ClassDeclarationSyntax> ClassDeclaration { get; init; }

        /// <summary>
        /// Gets a value indicating whether the attributed class is nested within another type.
        /// </summary>
        public bool IsNested => ClassDeclaration.Value.Parent is TypeDeclarationSyntax;
        /// <summary>
        /// Gets a value indicating whether the attributed class is declared as static.
        /// </summary>
        public bool IsStatic => ClassDeclaration.Value.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword));
        /// <summary>
        /// Gets a value indicating whether the attributed class is a generic type.
        /// </summary>
        public bool IsGeneric => ClassDeclaration.Value.TypeParameterList is not null;
        public bool IsPartial => ClassDeclaration.Value.Modifiers.Any(static m => m.IsKind(SyntaxKind.PartialKeyword));
        public Location PartialLocation => ClassDeclaration.Value.Identifier.GetLocation();

        public string HintBaseName => ClassSymbol.Value.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
    }
}
