using System.Text;
using EventsR3Generator.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EventsR3Generator;

[Generator(LanguageNames.CSharp)]
public partial class EventsR3Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Emit the R3EventAttribute definition in post-initialization
        context.RegisterPostInitializationOutput(EmitDefaultAttribute);

        // Use ForAttributeWithMetadataName to efficiently find classes decorated with R3EventAttribute
        var source = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Events.R3.R3EventAttribute",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
                },
                transform: static (ctx, cancellationToken) => Parse(ctx, cancellationToken)
                );

        // Generate source output for each attributed class
        context.RegisterSourceOutput(source, static (spc, item) => EmitSourceOutput(spc, item));
    }

    private static void EmitDefaultAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        var code = """
// <auto-generated />
namespace Events.R3
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class R3EventAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::Events.R3.R3EventAttribute"/> class with the specified target type.
        /// </summary>
        /// <param name="type">The target <see cref="global::System.Type"/> the attribute refers to.</param>
        public R3EventAttribute(global::System.Type type)
        {
            this.Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the target <see cref="global::System.Type"/> represented by this attribute.
        /// </summary>
        public global::System.Type Type { get; }
    }
}
""";
        context.AddSource("Events.R3.R3EventAttribute.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private static ParsedProperty Parse(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var attrib = ctx.Attributes[0];
        var arg = attrib.ConstructorArguments[0];
        var targetTypeSymbol = (INamedTypeSymbol)arg.Value!;

        // Extract method information from the target type
        var generatedMethods = ExtractGeneratedMethods(targetTypeSymbol);
        var targetTypeFullName = targetTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Get class namespace and name
        var containingNamespace = classSymbol.ContainingNamespace;
        var classNamespace = containingNamespace.IsGlobalNamespace ? string.Empty : containingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        return new()
        {
            ClassNamespace = classNamespace,
            ClassName = className,
            GeneratedMethods = generatedMethods,
            TargetTypeFullName = targetTypeFullName,
            ClassSymbol = new(classSymbol),
        };
    }

    private static EquatableArray<GeneratedMethodInfo> ExtractGeneratedMethods(INamedTypeSymbol targetType)
    {
        var methodInfos = targetType.GetMembers()
            .OfType<IEventSymbol>()
            .Where(static ev => ev is { DeclaredAccessibility: Accessibility.Public, IsStatic: false })
            .Select(static x => GenerateMethodInfo(x))
            .OrderBy(static x => x.EventName)
            .ToArray();
        return new(methodInfos);
    }

    private static GeneratedMethodInfo GenerateMethodInfo(IEventSymbol ev)
    {
        var eventType = ev.Type as INamedTypeSymbol;
        ITypeSymbol? payloadType = null;

        var isNonGenericSystemEventHandler = eventType is { IsGenericType: false } &&
            eventType.ContainingNamespace?.Name is "System" &&
            eventType.MetadataName is "EventHandler";
        if (isNonGenericSystemEventHandler)
        {
            // unit
        }
        else
        {
            var invoke = eventType?.DelegateInvokeMethod;
            if (invoke != null)
            {
                var ps = invoke.Parameters;
                if (ps.Length >= 1) payloadType = ps[^1].Type;
            }
        }

        if (payloadType is null && !isNonGenericSystemEventHandler)
        {
            // Default to System.Object since compilation reference is not available
            payloadType = null;
        }

        string observableElementType;
        bool useAsUnit = false;
        if (isNonGenericSystemEventHandler)
        {
            //eventType.Name
            observableElementType = "global::R3.Unit";
            useAsUnit = true;
        }
        else if (payloadType is not null)
        {
            observableElementType = payloadType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }
        else
        {
            observableElementType = "global::System.Object";
        }

        var delegateTypeDisplay = eventType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::System.Delegate";

        return new()
        {
            EventName = ev.Name,
            ObservableElementType = observableElementType,
            UseAsUnit = useAsUnit,
            DelegateType = delegateTypeDisplay,
        };
    }

    private static void EmitSourceOutput(SourceProductionContext spc, ParsedProperty item)
    {
        var hintName = $"{item.HintBaseName}.g.cs";
        spc.AddSource(hintName, SourceText.From(GenerateSource(item), Encoding.UTF8));
    }

    private static string GenerateSource(ParsedProperty item)
    {
        var methodsBuilder = new StringBuilder();

        foreach (var methodInfo in item.GeneratedMethods)
        {
            if (methodInfo.UseAsUnit)
            {
                var method = $$"""
        /// <summary>
        /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
        /// </summary>
        public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var rawObservable = global::R3.Observable.FromEventHandler(
                h => instance.{{methodInfo.EventName}} += h,
                h => instance.{{methodInfo.EventName}} -= h,
                cancellationToken
                );
            return global::R3.ObservableExtensions.AsUnitObservable(rawObservable);
        }
""";
                methodsBuilder.AppendLine(method);
            }
            else
            {
                var method = $$"""
        /// <summary>
        /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
        /// </summary>
        public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var rawObservable = global::R3.Observable.FromEvent<{{methodInfo.DelegateType}}, (global::System.Object?, {{methodInfo.ObservableElementType}} Args)>(
                h => new {{methodInfo.DelegateType}}((s, e) => h((s, e))),
                h => instance.{{methodInfo.EventName}} += h,
                h => instance.{{methodInfo.EventName}} -= h,
                cancellationToken
                );
            return global::R3.ObservableExtensions.Select(rawObservable, ep => ep.Args);
        }
""";
                methodsBuilder.AppendLine(method);
            }
        }

        // Namespace of the attribute-bearing class. Empty for global namespace.
        var classNamespace = item.ClassNamespace;
        var className = item.ClassName;

        if (classNamespace.Length > 0)
        {
            return $$"""
// <auto-generated />
#nullable enable
namespace {{classNamespace}}
{
    static partial class {{className}}
    {
{{methodsBuilder}}
    }
}
""";
        }
        else
        {
            return $$"""
// <auto-generated />
#nullable disable
static partial class {{className}}
{
{{methodsBuilder}}
}
""";
        }
    }


    /// <summary>
    /// Represents metadata describing a generated method for an observable event, including event name, element type,
    /// and delegate information.
    /// </summary>
    private sealed record GeneratedMethodInfo
    {
        /// <summary>
        /// Gets the name of the event associated with this instance.
        /// </summary>
        public required string EventName { get; init; }
        /// <summary>
        /// Gets the name of the element type that is being observed.
        /// </summary>
        public required string ObservableElementType { get; init; }
        /// <summary>
        /// Gets a value indicating whether to use R3.Unit as the element type for the observable.
        /// </summary>
        public required bool UseAsUnit { get; init; }
        /// <summary>
        /// Gets the fully qualified name of the delegate type used for the event handler.
        /// </summary>
        public required string DelegateType { get; init; }
    }

    /// <summary>
    /// Represents metadata for a class and its associated generated Observable extension methods as parsed from an
    /// R3EventAttribute.
    /// </summary>
    private sealed record ParsedProperty
    {
        /// <summary>
        /// Gets the fully qualified namespace of the attributed class, or an empty string if the class is in the global namespace.
        /// </summary>
        public required string ClassNamespace { get; init; }
        /// <summary>
        /// Gets the name of the attributed class.
        /// </summary>
        public required string ClassName { get; init; }
        /// <summary>
        /// Gets a collection of metadata describing the generated Observable extension methods for the attributed class.
        /// </summary>
        public required EquatableArray<GeneratedMethodInfo> GeneratedMethods { get; init; }
        /// <summary>
        /// Gets the fully qualified type name of the target type referenced in the R3EventAttribute.
        /// </summary>
        public required string TargetTypeFullName { get; init; }
        /// <summary>
        /// Gets the symbol of the attributed class.
        /// </summary>
        public required IgnoreEquality<INamedTypeSymbol> ClassSymbol { get; init; }

        public string HintBaseName => ClassSymbol.Value.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
    }
}
