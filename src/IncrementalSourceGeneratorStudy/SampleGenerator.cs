using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace IncrementalSourceGeneratorStudy;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Emit the R3EventAttribute definition in post-initialization
        context.RegisterPostInitializationOutput(EmitDefaultAttribute);

        // Use ForAttributeWithMetadataName to efficiently find classes decorated with R3EventAttribute
        var source = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Events.R3.R3EventAttribute",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
                },
                transform: static (ctx, cancellationToken) => Parse(ctx, cancellationToken)
                );

        // Generate source output for each attributed class
        context.RegisterSourceOutput(source, static (spc, item) => EmitSourceOutput(spc, item));
    }

    private static void EmitDefaultAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        var code = """
// <auto-generated />
namespace Events.R3
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class R3EventAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::Events.R3.R3EventAttribute"/> class with the specified target type.
        /// </summary>
        /// <param name="type">The target <see cref="global::System.Type"/> the attribute refers to.</param>
        public R3EventAttribute(global::System.Type type)
        {
            this.Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the target <see cref="global::System.Type"/> represented by this attribute.
        /// </summary>
        public global::System.Type Type { get; }
    }
}
""";
        context.AddSource("Events.R3.R3EventAttribute.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private static ParsedProperty Parse(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var attrib = ctx.Attributes[0];
        var arg = attrib.ConstructorArguments[0];
        var targetTypeSymbol = (INamedTypeSymbol)arg.Value!;

        // Extract method information from the target type
        var generatedMethods = ExtractGeneratedMethods(targetTypeSymbol);
        var targetTypeFullName = targetTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Get class namespace and name
        var containingNamespace = classSymbol.ContainingNamespace;
        var classNamespace = containingNamespace.IsGlobalNamespace ? string.Empty : containingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        return new(
            ClassNamespace: classNamespace,
            ClassName: className,
            GeneratedMethods: generatedMethods,
            TargetTypeFullName: targetTypeFullName
        );
    }

    private static System.Collections.Immutable.ImmutableArray<GeneratedMethodInfo> ExtractGeneratedMethods(INamedTypeSymbol targetType)
    {
        var methods = System.Collections.Immutable.ImmutableArray.CreateBuilder<GeneratedMethodInfo>();

        foreach (var member in targetType.GetMembers())
        {
            if (member is not IEventSymbol { DeclaredAccessibility: Accessibility.Public } ev) continue;

            var eventType = ev.Type as INamedTypeSymbol;
            ITypeSymbol? payloadType = null;

            if (eventType != null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler")
            {
                // unit
            }
            else if (eventType != null && eventType.IsGenericType && eventType.ConstructedFrom?.ToDisplayString() == "System.EventHandler<TEventArgs>")
            {
                payloadType = eventType.TypeArguments[0];
            }
            else
            {
                var invoke = eventType?.DelegateInvokeMethod;
                if (invoke != null)
                {
                    var ps = invoke.Parameters;
                    if (ps.Length >= 1) payloadType = ps[^1].Type;
                }
            }

            if (payloadType is null && !(eventType is not null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler"))
            {
                // Default to System.Object since compilation reference is not available
                payloadType = null;
            }

            string observableElementType;
            bool useAsUnit = false;
            if (eventType is not null && !eventType.IsGenericType && eventType.ToDisplayString() == "System.EventHandler")
            {
                observableElementType = "global::R3.Unit";
                useAsUnit = true;
            }
            else if (payloadType is not null)
            {
                observableElementType = payloadType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
            else
            {
                observableElementType = "global::System.Object";
            }

            var delegateTypeDisplay = eventType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::System.Delegate";

            methods.Add(new GeneratedMethodInfo(
                EventName: ev.Name,
                ObservableElementType: observableElementType,
                UseAsUnit: useAsUnit,
                DelegateType: delegateTypeDisplay
            ));
        }

        return methods.ToImmutable();
    }

    private static void EmitSourceOutput(SourceProductionContext spc, ParsedProperty item)
    {
        var methodsBuilder = new StringBuilder();

        foreach (var methodInfo in item.GeneratedMethods)
        {
            if (methodInfo.UseAsUnit)
            {
                var method = $$"""
                                /// <summary>
                                /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
                                /// </summary>
                                public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
                                {
                                    var rawObservable = global::R3.Observable.FromEventHandler(
                                        h => instance.{{methodInfo.EventName}} += h,
                                        h => instance.{{methodInfo.EventName}} -= h,
                                        cancellationToken
                                        );
                                    return rawObservable.AsUnitObservable();
                                }
""";
                methodsBuilder.AppendLine(method);
            }
            else
            {
                var method = $$"""
        /// <summary>
        /// Returns an Observable for <c>{{methodInfo.EventName}}</c>.
        /// </summary>
        public static global::R3.Observable<{{methodInfo.ObservableElementType}}> {{methodInfo.EventName}}AsObservable(this {{item.TargetTypeFullName}} instance, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var rawObservable = global::R3.Observable.FromEvent<{{methodInfo.DelegateType}}, (global::System.Object?, {{methodInfo.ObservableElementType}} Args)>(
                static h => new {{methodInfo.DelegateType}}((s, e) => h((s, e))),
                h => instance.{{methodInfo.EventName}} += h,
                h => instance.{{methodInfo.EventName}} -= h,
                cancellationToken
                );
            return global::R3.ObservableExtensions.Select(rawObservable, ep => ep.Args);
        }
""";
                methodsBuilder.AppendLine(method);
            }
        }

        // Namespace of the attribute-bearing class. Empty for global namespace.
        var classNamespace = item.ClassNamespace;
        var className = item.ClassName;

        string sourceText;
        if (classNamespace.Length > 0)
        {
            sourceText = $$"""
// <auto-generated />
namespace {{classNamespace}}
{
    static partial class {{className}}
    {
{{methodsBuilder}}
    }
}
""";
        }
        else
        {
            sourceText = $$"""
// <auto-generated />
static partial class {{className}}
{
{{methodsBuilder}}
}
""";
        }

        // File name: <namespace>.<ClassName>.g.cs (or <ClassName>.g.cs for global namespace)
        var fileName = string.IsNullOrEmpty(classNamespace)
            ? $"{className}.g.cs"
            : $"{classNamespace}.{className}.g.cs";

        spc.AddSource(fileName, SourceText.From(sourceText, Encoding.UTF8));
    }

    /// <summary>
    /// Represents metadata about a generated Observable extension method.
    /// </summary>
    private sealed record GeneratedMethodInfo(string EventName, string ObservableElementType, bool UseAsUnit, string DelegateType);

    private sealed record ParsedProperty(
        string ClassNamespace,
        string ClassName,
        System.Collections.Immutable.ImmutableArray<GeneratedMethodInfo> GeneratedMethods,
        string TargetTypeFullName);
}
